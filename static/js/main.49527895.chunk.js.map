{"version":3,"sources":["candy-machine.ts","connection.tsx","MintButton.tsx","Home.tsx","Logo.png","App.tsx","reportWebVitals.ts","index.tsx","utils.ts"],"names":["CANDY_MACHINE_PROGRAM","anchor","PublicKey","TOKEN_METADATA_PROGRAM_ID","awaitTransactionSignatureConfirmation","txid","timeout","connection","a","queryStatus","done","status","slot","confirmations","err","subId","Promise","resolve","reject","setTimeout","console","log","getSignatureStatuses","signatureStatuses","value","sleep","_signatureSubscriptions","removeSignatureListener","createAssociatedTokenAccountInstruction","associatedTokenAddress","payer","walletAddress","splTokenMintAddress","keys","pubkey","isSigner","isWritable","SystemProgram","programId","TOKEN_PROGRAM_ID","SYSVAR_RENT_PUBKEY","TransactionInstruction","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","data","Buffer","from","getCandyMachineState","anchorWallet","candyMachineId","tokenMintPublicKey","provider","preflightCommitment","fetchIdl","idl","program","account","candyMachine","fetch","state","itemsAvailable","toNumber","itemsRedeemed","itemsRemaining","presale","whitelistMintSettings","goLiveDate","Date","getTime","getTokenWallet","associatedAddress","getAccountInfo","accountInfo","balance","getTokenAccountBalance","Number","amount","id","paymentTokenExists","paymentTokenCount","isSoldOut","isActive","endSettings","endSettingType","date","number","isPresale","treasury","wallet","tokenMint","gatekeeper","hiddenSettings","price","getMasterEdition","mint","findProgramAddress","toBuffer","getMetadata","getCandyMachineCreator","mintOneToken","Keypair","generate","getAtaForMint","publicKey","userTokenAccountAddress","userPayingAccountAddress","candyMachineAddress","remainingAccounts","signers","cleanupInstructions","MintLayout","span","getMinimumBalanceForRentExemption","fromPubkey","newAccountPubkey","space","lamports","createAccount","Token","createInitMintInstruction","createMintToInstruction","instructions","getNetworkToken","gatekeeperNetwork","push","expireOnUse","CIVIC","getNetworkExpire","whitelistToken","mode","burnEveryTime","whitelistBurnAuthority","createApproveInstruction","createRevokeInstruction","transferAuthority","metadataAddress","masterEdition","candyMachineCreator","creatorBump","instruction","mintNft","accounts","metadata","mintAuthority","updateAuthority","tokenMetadataProgram","tokenProgram","systemProgram","rent","clock","SYSVAR_CLOCK_PUBKEY","recentBlockhashes","SYSVAR_RECENT_BLOCKHASHES_PUBKEY","instructionSysvarAccount","SYSVAR_INSTRUCTIONS_PUBKEY","length","undefined","sendTransactions","txs","map","t","ms","SequenceType","instructionSet","signersSet","sequenceType","Parallel","commitment","successCallback","ind","failCallback","block","WalletNotConnectedError","unsignedTxns","getRecentBlockhash","i","transaction","Transaction","forEach","add","recentBlockhash","blockhash","setSigners","s","partialSign","signAllTransactions","signedTxns","pendingTxns","breakEarlyObject","breakEarly","signedTxnPromise","sendSignedTransaction","signedTransaction","then","catch","reason","StopOnFailure","all","getUnixTs","DEFAULT_TIMEOUT","rawTransaction","serialize","startTime","sendRawTransaction","skipPreflight","confirmation","Error","error","simulateResult","simulateTransaction","logs","line","startsWith","slice","JSON","stringify","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","args","encoding","_rpcRequest","res","message","result","onSignature","context","e","CTAButton","styled","Button","MintButton","onMint","isMinting","useGateway","requestGatewayToken","gatewayStatus","useState","clicked","setClicked","useEffect","GatewayStatus","ACTIVE","disabled","onClick","variant","CircularProgress","ConnectButton","WalletDialogButton","DisconnectButton","WalletDisconnectButton","Item","props","style","marginTop","color","fontSize","children","shortenAddress","address","chars","Home","isUserMinting","setIsUserMinting","setCandyMachine","open","severity","alertState","setAlertState","useWallet","setPaymentTokenExists","setPaymentTokenCount","useMemo","signTransaction","refreshCandyMachineState","useCallback","cndy","document","getElementById","click","connected","mintTxId","txTimeout","msg","code","window","location","reload","indexOf","display","flexDirection","alignItems","justifyContent","textAlign","width","toBase58","className","marginBottom","href","src","alt","Snackbar","autoHideDuration","onClose","Alert","theme","createTheme","palette","type","getCandyMachineId","network","rpcHost","Connection","startDateSeed","parseInt","process","REACT_APP_CANDY_START_DATE","App","endpoint","clusterApiUrl","wallets","getPhantomWallet","getSolflareWallet","getSlopeWallet","getSolletWallet","getSolletExtensionWallet","ThemeProvider","ConnectionProvider","WalletProvider","autoConnect","startDate","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","Intl","NumberFormat","minimumFractionDigits","maximumFractionDigits","buyer"],"mappings":"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","file":"static/js/main.49527895.chunk.js","sourcesContent":["import * as anchor from \"@project-serum/anchor\";\n\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from \"@solana/spl-token\";\nimport { SystemProgram, PublicKey } from \"@solana/web3.js\";\nimport { sendTransactions } from \"./connection\";\n\nimport {\n    CIVIC,\n    getAtaForMint,\n    getNetworkExpire,\n    getNetworkToken,\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n} from \"./utils\";\n\nexport const CANDY_MACHINE_PROGRAM = new anchor.web3.PublicKey(\n    \"cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ\"\n);\n\nconst TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\n    \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\"\n);\n\ninterface CandyMachineState {\n    paymentTokenExists: boolean;\n    paymentTokenCount: number;\n    itemsAvailable: number;\n    itemsRedeemed: number;\n    itemsRemaining: number;\n    treasury: anchor.web3.PublicKey;\n    tokenMint: anchor.web3.PublicKey;\n    isSoldOut: boolean;\n    isActive: boolean;\n    isPresale: boolean;\n    goLiveDate: anchor.BN;\n    price: anchor.BN;\n    gatekeeper: null | {\n        expireOnUse: boolean;\n        gatekeeperNetwork: anchor.web3.PublicKey;\n    };\n    endSettings: null | [number, anchor.BN];\n    whitelistMintSettings: null | {\n        mode: any;\n        mint: anchor.web3.PublicKey;\n        presale: boolean;\n        discountPrice: null | anchor.BN;\n    };\n    hiddenSettings: null | {\n        name: string;\n        uri: string;\n        hash: Uint8Array;\n    };\n}\n\nexport interface CandyMachineAccount {\n    id: anchor.web3.PublicKey;\n    program: anchor.Program;\n    state: CandyMachineState;\n}\n\nexport const awaitTransactionSignatureConfirmation = async (\n    txid: anchor.web3.TransactionSignature,\n    timeout: number,\n    connection: anchor.web3.Connection,\n    queryStatus = false\n): Promise<anchor.web3.SignatureStatus | null | void> => {\n    let done = false;\n    let status: anchor.web3.SignatureStatus | null | void = {\n        slot: 0,\n        confirmations: 0,\n        err: null,\n    };\n    let subId = 0;\n    status = await new Promise(async (resolve, reject) => {\n        setTimeout(() => {\n            if (done) {\n                return;\n            }\n            done = true;\n            console.log(\"Rejecting for timeout...\");\n            reject({ timeout: true });\n        }, timeout);\n\n        while (!done && queryStatus) {\n            // eslint-disable-next-line no-loop-func\n            (async () => {\n                try {\n                    const signatureStatuses =\n                        await connection.getSignatureStatuses([txid]);\n                    status = signatureStatuses && signatureStatuses.value[0];\n                    if (!done) {\n                        if (!status) {\n                            console.log(\"REST null result for\", txid, status);\n                        } else if (status.err) {\n                            console.log(\"REST error for\", txid, status);\n                            done = true;\n                            reject(status.err);\n                        } else if (!status.confirmations) {\n                            console.log(\n                                \"REST no confirmations for\",\n                                txid,\n                                status\n                            );\n                        } else {\n                            console.log(\"REST confirmation for\", txid, status);\n                            done = true;\n                            resolve(status);\n                        }\n                    }\n                } catch (e) {\n                    if (!done) {\n                        console.log(\"REST connection error: txid\", txid, e);\n                    }\n                }\n            })();\n            await sleep(2000);\n        }\n    });\n\n    //@ts-ignore\n    if (connection._signatureSubscriptions[subId]) {\n        connection.removeSignatureListener(subId);\n    }\n    done = true;\n    console.log(\"Returning status\", status);\n    return status;\n};\n\nconst createAssociatedTokenAccountInstruction = (\n    associatedTokenAddress: anchor.web3.PublicKey,\n    payer: anchor.web3.PublicKey,\n    walletAddress: anchor.web3.PublicKey,\n    splTokenMintAddress: anchor.web3.PublicKey\n) => {\n    const keys = [\n        { pubkey: payer, isSigner: true, isWritable: true },\n        { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\n        { pubkey: walletAddress, isSigner: false, isWritable: false },\n        { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\n        {\n            pubkey: anchor.web3.SystemProgram.programId,\n            isSigner: false,\n            isWritable: false,\n        },\n        { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n        {\n            pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n            isSigner: false,\n            isWritable: false,\n        },\n    ];\n    return new anchor.web3.TransactionInstruction({\n        keys,\n        programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n        data: Buffer.from([]),\n    });\n};\n\nexport const getCandyMachineState = async (\n    anchorWallet: anchor.Wallet,\n    candyMachineId: anchor.web3.PublicKey,\n    connection: anchor.web3.Connection,\n    tokenMintPublicKey: PublicKey,\n    payer: PublicKey,\n): Promise<CandyMachineAccount> => {\n    const provider = new anchor.Provider(connection, anchorWallet, {\n        preflightCommitment: \"recent\",\n    });\n\n    const idl = await anchor.Program.fetchIdl(CANDY_MACHINE_PROGRAM, provider);\n\n    const program = new anchor.Program(idl, CANDY_MACHINE_PROGRAM, provider);\n\n    const state: any = await program.account.candyMachine.fetch(candyMachineId);\n    const itemsAvailable = state.data.itemsAvailable.toNumber();\n    const itemsRedeemed = state.itemsRedeemed.toNumber();\n    const itemsRemaining = itemsAvailable - itemsRedeemed;\n\n    const presale =\n        state.data.whitelistMintSettings &&\n        state.data.whitelistMintSettings.presale &&\n        (!state.data.goLiveDate ||\n            state.data.goLiveDate.toNumber() > new Date().getTime() / 1000);\n\n    /* Address to store the new payment token in for the user */\n    const associatedAddress = await getTokenWallet(payer, tokenMintPublicKey);\n\n    const accountInfo = await connection.getAccountInfo(\n        associatedAddress,\n    );\n\n    let balance = 0;\n\n    if (accountInfo) {\n        const { value } = await connection.getTokenAccountBalance(\n            associatedAddress,\n        );\n\n        balance = Number(value.amount);\n    }\n\n    return {\n        id: candyMachineId,\n        program,\n        state: {\n            paymentTokenExists: accountInfo !== null,\n            paymentTokenCount: balance,\n            itemsAvailable,\n            itemsRedeemed,\n            itemsRemaining,\n            isSoldOut: itemsRemaining === 0,\n            isActive:\n                (presale ||\n                    state.data.goLiveDate?.toNumber() <\n                        new Date().getTime() / 1000) &&\n                (state.data.endSettings\n                    ? state.data.endSettings.endSettingType.date\n                        ? state.data.endSettings.number.toNumber() >\n                          new Date().getTime() / 1000\n                        : itemsRedeemed <\n                          state.data.endSettings.number.toNumber()\n                    : true),\n            isPresale: presale,\n            goLiveDate: state.data.goLiveDate,\n            treasury: state.wallet,\n            tokenMint: state.tokenMint,\n            gatekeeper: state.data.gatekeeper,\n            endSettings: state.data.endSettings,\n            whitelistMintSettings: state.data.whitelistMintSettings,\n            hiddenSettings: state.data.hiddenSettings,\n            price: state.data.price,\n        },\n    };\n};\n\nconst getMasterEdition = async (\n    mint: anchor.web3.PublicKey\n): Promise<anchor.web3.PublicKey> => {\n    return (\n        await anchor.web3.PublicKey.findProgramAddress(\n            [\n                Buffer.from(\"metadata\"),\n                TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n                mint.toBuffer(),\n                Buffer.from(\"edition\"),\n            ],\n            TOKEN_METADATA_PROGRAM_ID\n        )\n    )[0];\n};\n\nconst getMetadata = async (\n    mint: anchor.web3.PublicKey\n): Promise<anchor.web3.PublicKey> => {\n    return (\n        await anchor.web3.PublicKey.findProgramAddress(\n            [\n                Buffer.from(\"metadata\"),\n                TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n                mint.toBuffer(),\n            ],\n            TOKEN_METADATA_PROGRAM_ID\n        )\n    )[0];\n};\n\nconst getTokenWallet = async (\n    wallet: anchor.web3.PublicKey,\n    mint: anchor.web3.PublicKey\n) => {\n    return (\n        await anchor.web3.PublicKey.findProgramAddress(\n            [wallet.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\n            SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n        )\n    )[0];\n};\n\nexport const getCandyMachineCreator = async (\n    candyMachine: anchor.web3.PublicKey\n): Promise<[anchor.web3.PublicKey, number]> => {\n    return await anchor.web3.PublicKey.findProgramAddress(\n        [Buffer.from(\"candy_machine\"), candyMachine.toBuffer()],\n        CANDY_MACHINE_PROGRAM\n    );\n};\n\nexport const mintOneToken = async (\n    candyMachine: CandyMachineAccount,\n    payer: anchor.web3.PublicKey\n): Promise<(string | undefined)[]> => {\n    const mint = anchor.web3.Keypair.generate();\n\n    const userTokenAccountAddress = (\n        await getAtaForMint(mint.publicKey, payer)\n    )[0];\n\n    const userPayingAccountAddress = candyMachine.state.tokenMint\n        ? (await getAtaForMint(candyMachine.state.tokenMint, payer))[0]\n        : payer;\n\n    const candyMachineAddress = candyMachine.id;\n    const remainingAccounts = [];\n    const signers: anchor.web3.Keypair[] = [mint];\n    const cleanupInstructions = [];\n    const instructions = [\n        anchor.web3.SystemProgram.createAccount({\n            fromPubkey: payer,\n            newAccountPubkey: mint.publicKey,\n            space: MintLayout.span,\n            lamports:\n                await candyMachine.program.provider.connection.getMinimumBalanceForRentExemption(\n                    MintLayout.span\n                ),\n            programId: TOKEN_PROGRAM_ID,\n        }),\n        Token.createInitMintInstruction(\n            TOKEN_PROGRAM_ID,\n            mint.publicKey,\n            0,\n            payer,\n            payer\n        ),\n        createAssociatedTokenAccountInstruction(\n            userTokenAccountAddress,\n            payer,\n            payer,\n            mint.publicKey\n        ),\n        Token.createMintToInstruction(\n            TOKEN_PROGRAM_ID,\n            mint.publicKey,\n            userTokenAccountAddress,\n            payer,\n            [],\n            1\n        ),\n    ];\n\n    if (candyMachine.state.gatekeeper) {\n        remainingAccounts.push({\n            pubkey: (\n                await getNetworkToken(\n                    payer,\n                    candyMachine.state.gatekeeper.gatekeeperNetwork\n                )\n            )[0],\n            isWritable: true,\n            isSigner: false,\n        });\n        if (candyMachine.state.gatekeeper.expireOnUse) {\n            remainingAccounts.push({\n                pubkey: CIVIC,\n                isWritable: false,\n                isSigner: false,\n            });\n            remainingAccounts.push({\n                pubkey: (\n                    await getNetworkExpire(\n                        candyMachine.state.gatekeeper.gatekeeperNetwork\n                    )\n                )[0],\n                isWritable: false,\n                isSigner: false,\n            });\n        }\n    }\n    if (candyMachine.state.whitelistMintSettings) {\n        const mint = new anchor.web3.PublicKey(\n            candyMachine.state.whitelistMintSettings.mint\n        );\n\n        const whitelistToken = (await getAtaForMint(mint, payer))[0];\n        remainingAccounts.push({\n            pubkey: whitelistToken,\n            isWritable: true,\n            isSigner: false,\n        });\n\n        if (candyMachine.state.whitelistMintSettings.mode.burnEveryTime) {\n            const whitelistBurnAuthority = anchor.web3.Keypair.generate();\n\n            remainingAccounts.push({\n                pubkey: mint,\n                isWritable: true,\n                isSigner: false,\n            });\n            remainingAccounts.push({\n                pubkey: whitelistBurnAuthority.publicKey,\n                isWritable: false,\n                isSigner: true,\n            });\n            signers.push(whitelistBurnAuthority);\n            const exists =\n                await candyMachine.program.provider.connection.getAccountInfo(\n                    whitelistToken\n                );\n            if (exists) {\n                instructions.push(\n                    Token.createApproveInstruction(\n                        TOKEN_PROGRAM_ID,\n                        whitelistToken,\n                        whitelistBurnAuthority.publicKey,\n                        payer,\n                        [],\n                        1\n                    )\n                );\n                cleanupInstructions.push(\n                    Token.createRevokeInstruction(\n                        TOKEN_PROGRAM_ID,\n                        whitelistToken,\n                        payer,\n                        []\n                    )\n                );\n            }\n        }\n    }\n\n    if (candyMachine.state.tokenMint) {\n        const transferAuthority = anchor.web3.Keypair.generate();\n\n        signers.push(transferAuthority);\n        remainingAccounts.push({\n            pubkey: userPayingAccountAddress,\n            isWritable: true,\n            isSigner: false,\n        });\n        remainingAccounts.push({\n            pubkey: transferAuthority.publicKey,\n            isWritable: false,\n            isSigner: true,\n        });\n\n        instructions.push(\n            Token.createApproveInstruction(\n                TOKEN_PROGRAM_ID,\n                userPayingAccountAddress,\n                transferAuthority.publicKey,\n                payer,\n                [],\n                candyMachine.state.price.toNumber()\n            )\n        );\n        cleanupInstructions.push(\n            Token.createRevokeInstruction(\n                TOKEN_PROGRAM_ID,\n                userPayingAccountAddress,\n                payer,\n                []\n            )\n        );\n    }\n    const metadataAddress = await getMetadata(mint.publicKey);\n    const masterEdition = await getMasterEdition(mint.publicKey);\n\n    const [candyMachineCreator, creatorBump] = await getCandyMachineCreator(\n        candyMachineAddress\n    );\n\n    instructions.push(\n        await candyMachine.program.instruction.mintNft(creatorBump, {\n            accounts: {\n                candyMachine: candyMachineAddress,\n                candyMachineCreator,\n                payer: payer,\n                wallet: candyMachine.state.treasury,\n                mint: mint.publicKey,\n                metadata: metadataAddress,\n                masterEdition,\n                mintAuthority: payer,\n                updateAuthority: payer,\n                tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n                tokenProgram: TOKEN_PROGRAM_ID,\n                systemProgram: SystemProgram.programId,\n                rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n                clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n                recentBlockhashes: anchor.web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                instructionSysvarAccount:\n                    anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,\n            },\n            remainingAccounts:\n                remainingAccounts.length > 0 ? remainingAccounts : undefined,\n        })\n    );\n\n    try {\n        return (\n            await sendTransactions(\n                candyMachine.program.provider.connection,\n                candyMachine.program.provider.wallet,\n                [instructions, cleanupInstructions],\n                [signers, []]\n            )\n        ).txs.map((t) => t.txid);\n    } catch (e) {\n        console.log(e);\n    }\n\n    return [];\n};\n\nexport const shortenAddress = (address: string, chars = 4): string => {\n    return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n};\n\nconst sleep = (ms: number): Promise<void> => {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n};\n","import {\n    Keypair,\n    Commitment,\n    Connection,\n    RpcResponseAndContext,\n    SignatureStatus,\n    SimulatedTransactionResponse,\n    Transaction,\n    TransactionInstruction,\n    TransactionSignature,\n    Blockhash,\n    FeeCalculator,\n} from \"@solana/web3.js\";\n\nimport { WalletNotConnectedError } from \"@solana/wallet-adapter-base\";\n\ninterface BlockhashAndFeeCalculator {\n    blockhash: Blockhash;\n    feeCalculator: FeeCalculator;\n}\n\nexport const getErrorForTransaction = async (\n    connection: Connection,\n    txid: string\n) => {\n    // wait for all confirmation before geting transaction\n    await connection.confirmTransaction(txid, \"max\");\n\n    const tx = await connection.getParsedConfirmedTransaction(txid);\n\n    const errors: string[] = [];\n    if (tx?.meta && tx.meta.logMessages) {\n        tx.meta.logMessages.forEach((log) => {\n            const regex = /Error: (.*)/gm;\n            let m;\n            while ((m = regex.exec(log)) !== null) {\n                // This is necessary to avoid infinite loops with zero-width matches\n                if (m.index === regex.lastIndex) {\n                    regex.lastIndex++;\n                }\n\n                if (m.length > 1) {\n                    errors.push(m[1]);\n                }\n            }\n        });\n    }\n\n    return errors;\n};\n\nexport enum SequenceType {\n    Sequential,\n    Parallel,\n    StopOnFailure,\n}\n\nexport async function sendTransactionsWithManualRetry(\n    connection: Connection,\n    wallet: any,\n    instructions: TransactionInstruction[][],\n    signers: Keypair[][]\n): Promise<(string | undefined)[]> {\n    let stopPoint = 0;\n    let tries = 0;\n    let lastInstructionsLength = null;\n    let toRemoveSigners: Record<number, boolean> = {};\n    instructions = instructions.filter((instr, i) => {\n        if (instr.length > 0) {\n            return true;\n        } else {\n            toRemoveSigners[i] = true;\n            return false;\n        }\n    });\n    let ids: string[] = [];\n    let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n\n    while (stopPoint < instructions.length && tries < 3) {\n        instructions = instructions.slice(stopPoint, instructions.length);\n        filteredSigners = filteredSigners.slice(\n            stopPoint,\n            filteredSigners.length\n        );\n\n        if (instructions.length === lastInstructionsLength) tries = tries + 1;\n        else tries = 0;\n\n        try {\n            if (instructions.length === 1) {\n                const id = await sendTransactionWithRetry(\n                    connection,\n                    wallet,\n                    instructions[0],\n                    filteredSigners[0],\n                    \"single\"\n                );\n                ids.push(id.txid);\n                stopPoint = 1;\n            } else {\n                const { txs } = await sendTransactions(\n                    connection,\n                    wallet,\n                    instructions,\n                    filteredSigners,\n                    SequenceType.StopOnFailure,\n                    \"single\"\n                );\n                ids = ids.concat(txs.map((t) => t.txid));\n            }\n        } catch (e) {\n            console.error(e);\n        }\n        console.log(\n            \"Died on \",\n            stopPoint,\n            \"retrying from instruction\",\n            instructions[stopPoint],\n            \"instructions length is\",\n            instructions.length\n        );\n        lastInstructionsLength = instructions.length;\n    }\n\n    return ids;\n}\n\nexport const sendTransactions = async (\n    connection: Connection,\n    wallet: any,\n    instructionSet: TransactionInstruction[][],\n    signersSet: Keypair[][],\n    sequenceType: SequenceType = SequenceType.Parallel,\n    commitment: Commitment = \"singleGossip\",\n    successCallback: (txid: string, ind: number) => void = (txid, ind) => {},\n    failCallback: (reason: string, ind: number) => boolean = (txid, ind) =>\n        false,\n    block?: BlockhashAndFeeCalculator\n): Promise<{ number: number; txs: { txid: string; slot: number }[] }> => {\n    if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n    const unsignedTxns: Transaction[] = [];\n\n    if (!block) {\n        block = await connection.getRecentBlockhash(commitment);\n    }\n\n    for (let i = 0; i < instructionSet.length; i++) {\n        const instructions = instructionSet[i];\n        const signers = signersSet[i];\n\n        if (instructions.length === 0) {\n            continue;\n        }\n\n        let transaction = new Transaction();\n        instructions.forEach((instruction) => transaction.add(instruction));\n        transaction.recentBlockhash = block.blockhash;\n        transaction.setSigners(\n            // fee payed by the wallet owner\n            wallet.publicKey,\n            ...signers.map((s) => s.publicKey)\n        );\n\n        if (signers.length > 0) {\n            transaction.partialSign(...signers);\n        }\n\n        unsignedTxns.push(transaction);\n    }\n\n    const signedTxns = await wallet.signAllTransactions(unsignedTxns);\n\n    const pendingTxns: Promise<{ txid: string; slot: number }>[] = [];\n\n    let breakEarlyObject = { breakEarly: false, i: 0 };\n    console.log(\n        \"Signed txns length\",\n        signedTxns.length,\n        \"vs handed in length\",\n        instructionSet.length\n    );\n    for (let i = 0; i < signedTxns.length; i++) {\n        const signedTxnPromise = sendSignedTransaction({\n            connection,\n            signedTransaction: signedTxns[i],\n        });\n\n        signedTxnPromise\n            .then(({ txid, slot }) => {\n                successCallback(txid, i);\n            })\n            .catch((reason) => {\n                // @ts-ignore\n                failCallback(signedTxns[i], i);\n                if (sequenceType === SequenceType.StopOnFailure) {\n                    breakEarlyObject.breakEarly = true;\n                    breakEarlyObject.i = i;\n                }\n            });\n\n        if (sequenceType !== SequenceType.Parallel) {\n            try {\n                await signedTxnPromise;\n            } catch (e) {\n                console.log(\"Caught failure\", e);\n                if (breakEarlyObject.breakEarly) {\n                    console.log(\"Died on \", breakEarlyObject.i);\n                    // Return the txn we failed on by index\n                    return {\n                        number: breakEarlyObject.i,\n                        txs: await Promise.all(pendingTxns),\n                    };\n                }\n            }\n        } else {\n            pendingTxns.push(signedTxnPromise);\n        }\n    }\n\n    if (sequenceType !== SequenceType.Parallel) {\n        await Promise.all(pendingTxns);\n    }\n\n    return { number: signedTxns.length, txs: await Promise.all(pendingTxns) };\n};\n\nexport const sendTransaction = async (\n    connection: Connection,\n    wallet: any,\n    instructions: TransactionInstruction[],\n    signers: Keypair[],\n    awaitConfirmation = true,\n    commitment: Commitment = \"singleGossip\",\n    includesFeePayer: boolean = false,\n    block?: BlockhashAndFeeCalculator\n) => {\n    if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n    let transaction = new Transaction();\n    instructions.forEach((instruction) => transaction.add(instruction));\n    transaction.recentBlockhash = (\n        block || (await connection.getRecentBlockhash(commitment))\n    ).blockhash;\n\n    if (includesFeePayer) {\n        transaction.setSigners(...signers.map((s) => s.publicKey));\n    } else {\n        transaction.setSigners(\n            // fee payed by the wallet owner\n            wallet.publicKey,\n            ...signers.map((s) => s.publicKey)\n        );\n    }\n\n    if (signers.length > 0) {\n        transaction.partialSign(...signers);\n    }\n    if (!includesFeePayer) {\n        transaction = await wallet.signTransaction(transaction);\n    }\n\n    const rawTransaction = transaction.serialize();\n    let options = {\n        skipPreflight: true,\n        commitment,\n    };\n\n    const txid = await connection.sendRawTransaction(rawTransaction, options);\n    let slot = 0;\n\n    if (awaitConfirmation) {\n        const confirmation = await awaitTransactionSignatureConfirmation(\n            txid,\n            DEFAULT_TIMEOUT,\n            connection,\n            commitment\n        );\n\n        if (!confirmation)\n            throw new Error(\"Timed out awaiting confirmation on transaction\");\n        slot = confirmation?.slot || 0;\n\n        if (confirmation?.err) {\n            const errors = await getErrorForTransaction(connection, txid);\n\n            console.log(errors);\n            throw new Error(`Raw transaction ${txid} failed`);\n        }\n    }\n\n    return { txid, slot };\n};\n\nexport const sendTransactionWithRetry = async (\n    connection: Connection,\n    wallet: any,\n    instructions: TransactionInstruction[],\n    signers: Keypair[],\n    commitment: Commitment = \"singleGossip\",\n    includesFeePayer: boolean = false,\n    block?: BlockhashAndFeeCalculator,\n    beforeSend?: () => void\n) => {\n    if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n    let transaction = new Transaction();\n    instructions.forEach((instruction) => transaction.add(instruction));\n    transaction.recentBlockhash = (\n        block || (await connection.getRecentBlockhash(commitment))\n    ).blockhash;\n\n    if (includesFeePayer) {\n        transaction.setSigners(...signers.map((s) => s.publicKey));\n    } else {\n        transaction.setSigners(\n            // fee payed by the wallet owner\n            wallet.publicKey,\n            ...signers.map((s) => s.publicKey)\n        );\n    }\n\n    if (signers.length > 0) {\n        transaction.partialSign(...signers);\n    }\n    if (!includesFeePayer) {\n        transaction = await wallet.signTransaction(transaction);\n    }\n\n    if (beforeSend) {\n        beforeSend();\n    }\n\n    const { txid, slot } = await sendSignedTransaction({\n        connection,\n        signedTransaction: transaction,\n    });\n\n    return { txid, slot };\n};\n\nexport const getUnixTs = () => {\n    return new Date().getTime() / 1000;\n};\n\nconst DEFAULT_TIMEOUT = 15000;\n\nexport async function sendSignedTransaction({\n    signedTransaction,\n    connection,\n    timeout = DEFAULT_TIMEOUT,\n}: {\n    signedTransaction: Transaction;\n    connection: Connection;\n    sendingMessage?: string;\n    sentMessage?: string;\n    successMessage?: string;\n    timeout?: number;\n}): Promise<{ txid: string; slot: number }> {\n    const rawTransaction = signedTransaction.serialize();\n    const startTime = getUnixTs();\n    let slot = 0;\n    const txid: TransactionSignature = await connection.sendRawTransaction(\n        rawTransaction,\n        {\n            skipPreflight: true,\n        }\n    );\n\n    console.log(\"Started awaiting confirmation for\", txid);\n\n    let done = false;\n    (async () => {\n        while (!done && getUnixTs() - startTime < timeout) {\n            connection.sendRawTransaction(rawTransaction, {\n                skipPreflight: true,\n            });\n            await sleep(500);\n        }\n    })();\n    try {\n        const confirmation = await awaitTransactionSignatureConfirmation(\n            txid,\n            timeout,\n            connection,\n            \"recent\",\n            true\n        );\n\n        if (!confirmation)\n            throw new Error(\"Timed out awaiting confirmation on transaction\");\n\n        if (confirmation.err) {\n            console.error(confirmation.err);\n            throw new Error(\"Transaction failed: Custom instruction error\");\n        }\n\n        slot = confirmation?.slot || 0;\n    } catch (err: any) {\n        console.error(\"Timeout Error caught\", err);\n        if (err.timeout) {\n            throw new Error(\"Timed out awaiting confirmation on transaction\");\n        }\n        let simulateResult: SimulatedTransactionResponse | null = null;\n        try {\n            simulateResult = (\n                await simulateTransaction(\n                    connection,\n                    signedTransaction,\n                    \"single\"\n                )\n            ).value;\n        } catch (e) {}\n        if (simulateResult && simulateResult.err) {\n            if (simulateResult.logs) {\n                for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n                    const line = simulateResult.logs[i];\n                    if (line.startsWith(\"Program log: \")) {\n                        throw new Error(\n                            \"Transaction failed: \" +\n                                line.slice(\"Program log: \".length)\n                        );\n                    }\n                }\n            }\n            throw new Error(JSON.stringify(simulateResult.err));\n        }\n        // throw new Error('Transaction failed');\n    } finally {\n        done = true;\n    }\n\n    console.log(\"Latency\", txid, getUnixTs() - startTime);\n    return { txid, slot };\n}\n\nasync function simulateTransaction(\n    connection: Connection,\n    transaction: Transaction,\n    commitment: Commitment\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n    // @ts-ignore\n    transaction.recentBlockhash = await connection._recentBlockhash(\n        // @ts-ignore\n        connection._disableBlockhashCaching\n    );\n\n    const signData = transaction.serializeMessage();\n    // @ts-ignore\n    const wireTransaction = transaction._serialize(signData);\n    const encodedTransaction = wireTransaction.toString(\"base64\");\n    const config: any = { encoding: \"base64\", commitment };\n    const args = [encodedTransaction, config];\n\n    // @ts-ignore\n    const res = await connection._rpcRequest(\"simulateTransaction\", args);\n    if (res.error) {\n        throw new Error(\"failed to simulate transaction: \" + res.error.message);\n    }\n    return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(\n    txid: TransactionSignature,\n    timeout: number,\n    connection: Connection,\n    commitment: Commitment = \"recent\",\n    queryStatus = false\n): Promise<SignatureStatus | null | void> {\n    let done = false;\n    let status: SignatureStatus | null | void = {\n        slot: 0,\n        confirmations: 0,\n        err: null,\n    };\n    let subId = 0;\n    status = await new Promise(async (resolve, reject) => {\n        setTimeout(() => {\n            if (done) {\n                return;\n            }\n            done = true;\n            console.log(\"Rejecting for timeout...\");\n            reject({ timeout: true });\n        }, timeout);\n        try {\n            subId = connection.onSignature(\n                txid,\n                (result, context) => {\n                    done = true;\n                    status = {\n                        err: result.err,\n                        slot: context.slot,\n                        confirmations: 0,\n                    };\n                    if (result.err) {\n                        console.log(\"Rejected via websocket\", result.err);\n                        reject(status);\n                    } else {\n                        console.log(\"Resolved via websocket\", result);\n                        resolve(status);\n                    }\n                },\n                commitment\n            );\n        } catch (e) {\n            done = true;\n            console.error(\"WS error in setup\", txid, e);\n        }\n        while (!done && queryStatus) {\n            // eslint-disable-next-line no-loop-func\n            (async () => {\n                try {\n                    const signatureStatuses =\n                        await connection.getSignatureStatuses([txid]);\n                    status = signatureStatuses && signatureStatuses.value[0];\n                    if (!done) {\n                        if (!status) {\n                            console.log(\"REST null result for\", txid, status);\n                        } else if (status.err) {\n                            console.log(\"REST error for\", txid, status);\n                            done = true;\n                            reject(status.err);\n                        } else if (!status.confirmations) {\n                            console.log(\n                                \"REST no confirmations for\",\n                                txid,\n                                status\n                            );\n                        } else {\n                            console.log(\"REST confirmation for\", txid, status);\n                            done = true;\n                            resolve(status);\n                        }\n                    }\n                } catch (e) {\n                    if (!done) {\n                        console.log(\"REST connection error: txid\", txid, e);\n                    }\n                }\n            })();\n            await sleep(2000);\n        }\n    });\n\n    //@ts-ignore\n    if (connection._signatureSubscriptions[subId])\n        connection.removeSignatureListener(subId);\n    done = true;\n    console.log(\"Returning status\", status);\n    return status;\n}\nexport function sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","import styled from \"styled-components\";\nimport Button from \"@material-ui/core/Button\";\nimport { CandyMachineAccount } from \"./candy-machine\";\nimport { CircularProgress } from \"@material-ui/core\";\nimport { GatewayStatus, useGateway } from \"@civic/solana-gateway-react\";\nimport { useEffect, useState } from \"react\";\n\nexport const CTAButton = styled(Button)`\n    width: 200px;\n    height: 60px;\n    background-color: #92e643 !important;\n    color: #0d0d0d !important;\n    font-size: 30px !important;\n`; // add your own styles here\n\nexport const MintButton = ({\n    onMint,\n    candyMachine,\n    isMinting,\n}: {\n    onMint: () => Promise<void>;\n    candyMachine?: CandyMachineAccount;\n    isMinting: boolean;\n}) => {\n    const { requestGatewayToken, gatewayStatus } = useGateway();\n    const [clicked, setClicked] = useState(false);\n\n    useEffect(() => {\n        if (gatewayStatus === GatewayStatus.ACTIVE && clicked) {\n            onMint();\n            setClicked(false);\n        }\n    }, [gatewayStatus, clicked, setClicked, onMint]);\n\n    const getMintButtonContent = () => {\n        if (candyMachine?.state.isSoldOut) {\n            return \"SOLD OUT\";\n        } else if (isMinting) {\n            return <CircularProgress />;\n        } else if (candyMachine?.state.isPresale) {\n            return \"PRESALE MINT\";\n        } else if (clicked && candyMachine?.state.gatekeeper) {\n            return <CircularProgress />;\n        }\n\n        return \"MINT\";\n    };\n\n    return (\n        <CTAButton\n            disabled={\n                clicked ||\n                candyMachine?.state.isSoldOut ||\n                isMinting ||\n                !candyMachine?.state.isActive\n            }\n            onClick={async () => {\n                setClicked(true);\n                if (\n                    candyMachine?.state.isActive &&\n                    candyMachine?.state.gatekeeper\n                ) {\n                    if (gatewayStatus === GatewayStatus.ACTIVE) {\n                        setClicked(true);\n                    } else {\n                        await requestGatewayToken();\n                    }\n                } else {\n                    await onMint();\n                    setClicked(false);\n                }\n            }}\n            variant=\"contained\"\n        >\n            {getMintButtonContent()}\n        </CTAButton>\n    );\n};\n","import { useEffect, useMemo, useState, useCallback } from \"react\";\nimport * as anchor from \"@project-serum/anchor\";\n\nimport styled from \"styled-components\";\nimport { Snackbar } from \"@material-ui/core\";\nimport Alert from \"@material-ui/lab/Alert\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { WalletDialogButton, WalletDisconnectButton, } from \"@solana/wallet-adapter-material-ui\";\nimport {\n    awaitTransactionSignatureConfirmation,\n    CandyMachineAccount,\n    getCandyMachineState,\n    mintOneToken,\n} from \"./candy-machine\";\nimport { AlertState } from \"./utils\";\nimport { MintButton } from \"./MintButton\";\nimport Logo from \"./Logo.png\";\n\nconst ConnectButton = styled(WalletDialogButton)`\n    background-color: #92e643 !important;\n    color: #0d0d0d !important;\n    font-size: 30px !important;\n`;\n\nconst DisconnectButton = styled(WalletDisconnectButton)`\n    background-color: #92e643 !important;\n    color: #0d0d0d !important;\n    font-size: 20px !important;\n`;\n\nconst Item = (props: any) => {\n  return (\n      <span style={{\n          marginTop: '10px',\n          color: '#92e643',\n          fontSize: '24px',\n          ...props.style,\n      }}>\n          {props.children}\n      </span>\n  );\n}\n\nexport interface HomeProps {\n    candyMachineId?: anchor.web3.PublicKey;\n    connection: anchor.web3.Connection;\n    startDate: number;\n    txTimeout: number;\n    rpcHost: string;\n    tokenMintPublicKey: PublicKey;\n}\n\nexport const shortenAddress = (address: string, chars = 4): string => {\n    return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n};\n\nconst Home = (props: HomeProps) => {\n    const [isUserMinting, setIsUserMinting] = useState(false);\n    const [candyMachine, setCandyMachine] = useState<CandyMachineAccount>();\n    const [alertState, setAlertState] = useState<AlertState>({\n        open: false,\n        message: \"\",\n        severity: undefined,\n    });\n\n    const wallet = useWallet();\n\n    const [paymentTokenExists, setPaymentTokenExists] = useState(false);\n    const [paymentTokenCount, setPaymentTokenCount] = useState(0);\n\n    const anchorWallet = useMemo(() => {\n        if (\n            !wallet ||\n            !wallet.publicKey ||\n            !wallet.signAllTransactions ||\n            !wallet.signTransaction\n        ) {\n            return;\n        }\n\n        return {\n            publicKey: wallet.publicKey,\n            signAllTransactions: wallet.signAllTransactions,\n            signTransaction: wallet.signTransaction,\n        } as anchor.Wallet;\n    }, [wallet]);\n\n    const refreshCandyMachineState = useCallback(async () => {\n        if (!anchorWallet || !wallet.publicKey) {\n            return;\n        }\n\n        if (props.candyMachineId) {\n            try {\n                const cndy = await getCandyMachineState(\n                    anchorWallet,\n                    props.candyMachineId,\n                    props.connection,\n                    props.tokenMintPublicKey,\n                    wallet.publicKey,\n                );\n\n                setCandyMachine(cndy);\n                setPaymentTokenExists(cndy.state.paymentTokenExists);\n                setPaymentTokenCount(cndy.state.paymentTokenCount);\n            } catch (e) {\n                console.log(\"There was a problem fetching Candy Machine state\");\n                console.log(e);\n            }\n        }\n    }, [anchorWallet, props.candyMachineId, props.connection, wallet.publicKey, props.tokenMintPublicKey]);\n\n    const onMint = async () => {\n        try {\n            setIsUserMinting(true);\n            document.getElementById(\"#identity\")?.click();\n            if (wallet.connected && candyMachine?.program && wallet.publicKey) {\n                const mintTxId = (\n                    await mintOneToken(candyMachine, wallet.publicKey)\n                )[0];\n\n                let status: any = { err: true };\n                if (mintTxId) {\n                    status = await awaitTransactionSignatureConfirmation(\n                        mintTxId,\n                        props.txTimeout,\n                        props.connection,\n                        true\n                    );\n                }\n\n                if (status && !status.err) {\n                    setAlertState({\n                        open: true,\n                        message: \"Congratulations! Mint succeeded!\",\n                        severity: \"success\",\n                    });\n                } else {\n                    setAlertState({\n                        open: true,\n                        message: \"Mint failed! Please try again!\",\n                        severity: \"error\",\n                    });\n                }\n            }\n        } catch (error: any) {\n            let message = error.msg || \"Minting failed! Please try again!\";\n            if (!error.msg) {\n                if (!error.message) {\n                    message = \"Transaction Timeout! Please try again.\";\n                } else if (error.message.indexOf(\"0x137\")) {\n                    message = `SOLD OUT!`;\n                } else if (error.message.indexOf(\"0x135\")) {\n                    message = `Insufficient funds to mint. Please fund your wallet.`;\n                }\n            } else {\n                if (error.code === 311) {\n                    message = `SOLD OUT!`;\n                    window.location.reload();\n                } else if (error.code === 312) {\n                    message = `Minting period hasn't started yet.`;\n                }\n            }\n\n            setAlertState({\n                open: true,\n                message,\n                severity: \"error\",\n            });\n        } finally {\n            setIsUserMinting(false);\n        }\n    };\n\n    useEffect(() => {\n        refreshCandyMachineState();\n    }, [\n        anchorWallet,\n        props.candyMachineId,\n        props.connection,\n        refreshCandyMachineState,\n    ]);\n\n    return (\n        <main>\n            <div\n                style={{\n                    marginTop: '80px',\n                    display: 'flex',\n                    flexDirection: 'column',\n                    alignItems: 'center',\n                    justifyContent: 'center',\n                    textAlign: 'center',\n                }}\n            >\n                {wallet.connected && wallet.publicKey && (\n                    <>\n                                                \n                        {paymentTokenExists && (\n                            <>\n                                <div style={{ display: 'flex', width: '90%', justifyContent: 'space-between', fontSize: '28px' }}>\n                                    <Item>\n                                        Wallet: {shortenAddress(wallet.publicKey.toBase58() || \"\")}\n                                    </Item>\n\n                                    <Item>\n                                        Mint Cost: Free + Transaction Fees (~0.02 SOL)\n                                    </Item>\n                                </div>\n\n                                <div style={{ flexDirection: 'column', display: 'flex', alignItems: 'center', marginTop: '40px' }}>\n                                    {paymentTokenCount === 0 && (\n                                        <>\n                                            <Item style={{ fontSize: '30px' }}>\n                                                Congratulations, you have claimed all your 3D slugs!\n                                            </Item>\n\n                                            <DisconnectButton\n                                                style={{ marginTop: '30px' }}\n                                                className=\"button is-primary is-normal\"\n                                            >\n                                                Disconnect Wallet\n                                            </DisconnectButton>\n                                        </>\n                                    )}\n\n                                    {paymentTokenCount > 0 && (\n                                        <>\n                                            <Item style={{ fontSize: '30px', marginBottom: '30px' }}>\n                                                {`You can claim ${paymentTokenCount} 3D slug${paymentTokenCount === 1 ? '' : 's'}!`}\n                                            </Item>\n\n                                            <MintButton\n                                                onMint={onMint}\n                                                candyMachine={candyMachine}\n                                                isMinting={isUserMinting}\n                                            />\n                                        </>\n                                    )}\n                                </div>\n                            </>\n                        )}\n\n                        {candyMachine && !paymentTokenExists && (\n                            <>\n                                <div style={{ display: 'flex', width: '90%', justifyContent: 'space-between', fontSize: '28px' }}>\n                                    <Item>\n\n                                        Wallet: {shortenAddress(wallet.publicKey.toBase58() || \"\")}\n                                    </Item>\n\n                                    <Item>\n                                        Mint Cost: Free + Transaction Fees (~0.02 SOL)\n                                    </Item>\n                                </div>\n\n                                <Item style={{ marginTop: '60px', width: '600px' }}>\n                                    You are not eligible for any 3D Slugs. Please verify you have the correct wallet address connected.\n                                </Item>\n\n                                <Item style={{ marginTop: '40px', width: '600px' }}>\n                                    3D slugs were rewarded to users who burnt one or more slugs, or who participated in the rugged Dogs on the Block giveaway.\n                                </Item>\n\n                                <DisconnectButton\n                                    style={{ marginTop: '30px' }}\n                                    className=\"button is-primary is-normal\"\n                                    color=\"primary\"\n                                >\n                                    Disconnect Wallet\n                                </DisconnectButton>\n\n                                <a href=\"https://solslugs.com/#/3dslugs\" style={{ color: '#92e643', marginTop: '30px' }}>\n                                    Verify Eligibility\n                                </a>\n                            </>\n                        )}\n                    </>\n                )}\n\n                {!wallet.connected && (\n                    <>\n                        <p style={{ color: '#92e643', fontSize: '30px' }}>\n                            Connect your wallet to mint a 3D Slug!\n                        </p>\n\n                        <ConnectButton\n                            style={{ marginTop: \"1rem\" }}\n                            className=\"button is-primary is-normal\"\n                        />\n                    </>\n                )}\n\n                <img\n                    src={Logo}\n                    alt=''\n                    style={{\n                        width: '400px',\n                    }}\n                />\n            </div>\n\n            <Snackbar\n                open={alertState.open}\n                autoHideDuration={6000}\n                onClose={() => setAlertState({ ...alertState, open: false })}\n            >\n                <Alert\n                    onClose={() =>\n                        setAlertState({ ...alertState, open: false })\n                    }\n                    severity={alertState.severity}\n                >\n                    {alertState.message}\n                </Alert>\n            </Snackbar>\n        </main>\n    );\n\n    /*\n\n          {!wallet.connected ? (\n            <ConnectButton>Connect Wallet</ConnectButton>\n          ) : (\n            <>\n              <Header candyMachine={candyMachine} />\n              <MintContainer>\n                {candyMachine?.state.isActive &&\n                candyMachine?.state.gatekeeper &&\n                wallet.publicKey &&\n                wallet.signTransaction ? (\n                  <GatewayProvider\n                    wallet={{\n                      publicKey:\n                        wallet.publicKey ||\n                        new PublicKey(CANDY_MACHINE_PROGRAM),\n                      //@ts-ignore\n                      signTransaction: wallet.signTransaction,\n                    }}\n                    gatekeeperNetwork={\n                      candyMachine?.state?.gatekeeper?.gatekeeperNetwork\n                    }\n                    clusterUrl={rpcUrl}\n                    options={{ autoShowModal: false }}\n                  >\n                    <MintButton\n                      candyMachine={candyMachine}\n                      isMinting={isUserMinting}\n                      onMint={onMint}\n                    />\n                  </GatewayProvider>\n                ) : (\n                  <MintButton\n                    candyMachine={candyMachine}\n                    isMinting={isUserMinting}\n                    onMint={onMint}\n                  />\n                )}\n              </MintContainer>\n            </>\n          )}\n\n      </Container>\n\n      <Snackbar\n        open={alertState.open}\n        autoHideDuration={6000}\n        onClose={() => setAlertState({ ...alertState, open: false })}\n      >\n        <Alert\n          onClose={() => setAlertState({ ...alertState, open: false })}\n          severity={alertState.severity}\n        >\n          {alertState.message}\n        </Alert>\n      </Snackbar>\n    </Container>\n  );\n     */\n};\n\nexport default Home;\n","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAAXNSR0IArs4c6QAABO1JREFUeJzt3TGS1DgUBuCB4gAERByAC2xOwiGG2piQ2nCiPQVFSEwRcgESEiIusCEBJATcYDa2pmmhkWy5/X9f1lXTLY975q/3JMu+ugIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACDNg9kHEOB29gHsnL/BiR7OPgBgHgEAwQQABHs0+wAO6GzP/+32y+L1xx//dg323+dfi9dvX34dOl7v59fez1wqAAgmACCYAIBg5gBWNrrn33q8Z88fL16//vBX1+exLyoACCYAIJgAgGDmACarrZO/+f6i6edvrseOt7X3P18tXv/95N2kI8mgAoBgAgCCCQAIZg5gZb3r8P88/bTpeK1Gj6fn35YKAIIJAAgmACCYOYDJymvta+vw9tczkgoAggkACCYAIJg5gJWV6/i919offX9+eX5ar4OgjQoAggkACCYAIJg5gPHKZ90tnhPQ2tPO3p+/NT3/tlQAEEwAQDABAMHMAYx39tmA3NF7vso5FxqoACCYAIBgAgCC6Z/uGtrDl8/qK/XeU6+8P0C5V2C02eOtcP+D6P8BFQAEEwAQTABAsOj+5zcWcwBr9/CtWnvi3r0Ee3+WYM0fnK/o/wEVAAQTABBMAECwxP5n19fqey7A7h3qf0YFAMEEAAQTABAs4X4AZ3v+cp1/9LX5N9dvz35++fO15wjUev7a79O7rl97f+/5bJ3jWPv7O/ociwoAggkACCYAIFjCHMDC6J4x3ejzWXv2YW1OhTYqAAgmACCYAIBgcXMANa3r5LWfv7nuO55Lf1be1vcTGP39HZ0KAIIJAAgmACBY3BxA77pxa0/eO17Zs9bG33pdfPR4tZ782fNtv7+rg+3/L6kAIJgAgGACAILFzQHUlNeiz75H36VfB1Az+vdb4fsr7ydxqDkBFQAEEwAQTABAsLg5gNo991rV9q8PUOs5d/2cg1Lr+W69Z2Kr2vd39L0BKgAIJgAgmACAYAlzAGUPveiZW9ehR+9fp4/vr48KAIIJAAgmACBYwhzARa2Tn3Dpx78weh2fPioACCYAIJgAgGAJcwALe+s5W/evl8pr5dcer9Xo8fb2/V06FQAEEwAQTABAsLg5gKMbvc6+92f7jXb0/f8lFQAEEwAQTABAsPg5gNb7+vc+X771/b3j1eYEep9rUNuPP3q80ujzf8KhngNQUgFAMAEAwQQABIufA+jtQWe//4Sz90C8x/itPfDo8Q51P4S9UQFAMAEAwQQABIufAzihtwddtYfd4Fr1rde9p66zp137X1IBQDABAMEEAASLmwNofZac8fc93gbXURyaCgCCCQAIJgAgWNwcQLkfvLVHvUdPO/Ra+nt8ftS6/onx7SU4QwUAwQQABBMAEGx2v7aF0T312hbH+wdzFrOPd21b78U4+vlcUAFAMAEAwQQABIvqdy6EnnXJ+ViRCgCCCQAIJgAgWNxegAughz2jdy8HSyoACCYAIJgAgGD6zf2x7r3kfKxIBQDBBAAEEwAQzHUAO2fdW0+/JhUABBMAEEwAQDD91f5Y92YzKgAIJgAgmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgovwPj0GibqHVFoIAAAAASUVORK5CYII=\"","import \"./App.css\";\nimport { useMemo } from \"react\";\nimport * as anchor from \"@project-serum/anchor\";\nimport Home from \"./Home\";\n\nimport { clusterApiUrl, PublicKey } from \"@solana/web3.js\";\nimport { WalletAdapterNetwork } from \"@solana/wallet-adapter-base\";\nimport {\n    getPhantomWallet,\n    getSlopeWallet,\n    getSolflareWallet,\n    getSolletWallet,\n    getSolletExtensionWallet,\n} from \"@solana/wallet-adapter-wallets\";\n\nimport {\n    ConnectionProvider,\n    WalletProvider,\n} from \"@solana/wallet-adapter-react\";\nimport { WalletDialogProvider } from \"@solana/wallet-adapter-material-ui\";\n\nimport { ThemeProvider, createTheme } from \"@material-ui/core\";\n\nconst theme = createTheme({\n    palette: {\n        type: \"dark\",\n    },\n});\n\nconst getCandyMachineId = (): anchor.web3.PublicKey | undefined => {\n    try {\n        const candyMachineId = new anchor.web3.PublicKey(\n            'GZGMjeBjU997EfAPJhRsU96vWkaYvu4B5g9bdUkfSiaU',\n        );\n\n        return candyMachineId;\n    } catch (e) {\n        console.log(\"Failed to construct CandyMachineId\", e);\n        return undefined;\n    }\n};\n\nconst candyMachineId = getCandyMachineId();\nconst network = 'mainnet-beta' as WalletAdapterNetwork;\nconst rpcHost = 'https://ssc-dao.genesysgo.net/';\nconst connection = new anchor.web3.Connection(\n    rpcHost ? rpcHost : anchor.web3.clusterApiUrl(\"devnet\")\n);\n\nconst tokenMintPublicKey = new PublicKey(\n    '3DSLGYdPHcrhcuYNj4Gn6bwQYA5dyEmXjeQiY2vJPX6y',\n);\n\nconst startDateSeed = parseInt(process.env.REACT_APP_CANDY_START_DATE!, 10);\nconst txTimeoutInMilliseconds = 30000;\n\nconst App = () => {\n    const endpoint = useMemo(() => clusterApiUrl(network), []);\n\n    const wallets = useMemo(\n        () => [\n            getPhantomWallet(),\n            getSolflareWallet(),\n            getSlopeWallet(),\n            getSolletWallet({ network }),\n            getSolletExtensionWallet({ network }),\n        ],\n        []\n    );\n\n    return (\n        <ThemeProvider theme={theme}>\n            <ConnectionProvider endpoint={endpoint}>\n                <WalletProvider wallets={wallets} autoConnect>\n                    <WalletDialogProvider>\n                        <Home\n                            candyMachineId={candyMachineId}\n                            connection={connection}\n                            startDate={startDateSeed}\n                            txTimeout={txTimeoutInMilliseconds}\n                            rpcHost={rpcHost}\n                            tokenMintPublicKey={tokenMintPublicKey}\n                        />\n                    </WalletDialogProvider>\n                </WalletProvider>\n            </ConnectionProvider>\n        </ThemeProvider>\n    );\n};\n\nexport default App;\n","import { ReportHandler } from \"web-vitals\";\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n    if (onPerfEntry && onPerfEntry instanceof Function) {\n        import(\"web-vitals\").then(\n            ({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n                getCLS(onPerfEntry);\n                getFID(onPerfEntry);\n                getFCP(onPerfEntry);\n                getLCP(onPerfEntry);\n                getTTFB(onPerfEntry);\n            }\n        );\n    }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nimport \"./index.css\";\n\nReactDOM.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>,\n    document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import * as anchor from \"@project-serum/anchor\";\nimport { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { SystemProgram } from \"@solana/web3.js\";\nimport {\n    LAMPORTS_PER_SOL,\n    SYSVAR_RENT_PUBKEY,\n    TransactionInstruction,\n} from \"@solana/web3.js\";\n\nexport interface AlertState {\n    open: boolean;\n    message: string;\n    severity: \"success\" | \"info\" | \"warning\" | \"error\" | undefined;\n}\n\nexport const toDate = (value?: anchor.BN) => {\n    if (!value) {\n        return;\n    }\n\n    return new Date(value.toNumber() * 1000);\n};\n\nconst numberFormater = new Intl.NumberFormat(\"en-US\", {\n    style: \"decimal\",\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2,\n});\n\nexport const formatNumber = {\n    format: (val?: number) => {\n        if (!val) {\n            return \"--\";\n        }\n\n        return numberFormater.format(val);\n    },\n    asNumber: (val?: anchor.BN) => {\n        if (!val) {\n            return undefined;\n        }\n\n        return val.toNumber() / LAMPORTS_PER_SOL;\n    },\n};\n\nexport const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID =\n    new anchor.web3.PublicKey(\"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\");\n\nexport const CIVIC = new anchor.web3.PublicKey(\n    \"gatem74V238djXdzWnJf94Wo1DcnuGkfijbf3AuBhfs\"\n);\n\nexport const getAtaForMint = async (\n    mint: anchor.web3.PublicKey,\n    buyer: anchor.web3.PublicKey\n): Promise<[anchor.web3.PublicKey, number]> => {\n    return await anchor.web3.PublicKey.findProgramAddress(\n        [buyer.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\n        SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    );\n};\n\nexport const getNetworkExpire = async (\n    gatekeeperNetwork: anchor.web3.PublicKey\n): Promise<[anchor.web3.PublicKey, number]> => {\n    return await anchor.web3.PublicKey.findProgramAddress(\n        [gatekeeperNetwork.toBuffer(), Buffer.from(\"expire\")],\n        CIVIC\n    );\n};\n\nexport const getNetworkToken = async (\n    wallet: anchor.web3.PublicKey,\n    gatekeeperNetwork: anchor.web3.PublicKey\n): Promise<[anchor.web3.PublicKey, number]> => {\n    return await anchor.web3.PublicKey.findProgramAddress(\n        [\n            wallet.toBuffer(),\n            Buffer.from(\"gateway\"),\n            Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]),\n            gatekeeperNetwork.toBuffer(),\n        ],\n        CIVIC\n    );\n};\n\nexport function createAssociatedTokenAccountInstruction(\n    associatedTokenAddress: anchor.web3.PublicKey,\n    payer: anchor.web3.PublicKey,\n    walletAddress: anchor.web3.PublicKey,\n    splTokenMintAddress: anchor.web3.PublicKey\n) {\n    const keys = [\n        {\n            pubkey: payer,\n            isSigner: true,\n            isWritable: true,\n        },\n        {\n            pubkey: associatedTokenAddress,\n            isSigner: false,\n            isWritable: true,\n        },\n        {\n            pubkey: walletAddress,\n            isSigner: false,\n            isWritable: false,\n        },\n        {\n            pubkey: splTokenMintAddress,\n            isSigner: false,\n            isWritable: false,\n        },\n        {\n            pubkey: SystemProgram.programId,\n            isSigner: false,\n            isWritable: false,\n        },\n        {\n            pubkey: TOKEN_PROGRAM_ID,\n            isSigner: false,\n            isWritable: false,\n        },\n        {\n            pubkey: SYSVAR_RENT_PUBKEY,\n            isSigner: false,\n            isWritable: false,\n        },\n    ];\n    return new TransactionInstruction({\n        keys,\n        programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n        data: Buffer.from([]),\n    });\n}\n"],"sourceRoot":""}